Since this LISP interpreter is implemented in Python, there is no need for a Makefile.

Parsing:
-------
A simple lexer splits the input into tokens. Regular expressions for identifying valid
atoms, integers, and whitespace make tokenizing very easy. Then two input functions
(essentially input and input2, as described by Neelam on the cse.courses.cse755 newsgroup)
recursively parse the list of tokens, in one pass, building an S-Expression.

The two input functions recursively call each other to allow both dot and list notation
(but not mixed notation).


S-Expression implementation:
---------------------------
Conceptually, S-Expressions are represented using two of Python's basic data structures:
lists and strings. A simple S-expression is basically a list with one string; complex
S-expressions are binary trees with simple S-expressions at their leaves.

The implementation uses a class that provides all the primitive functions (such as car,
cdr, cons) and some utility functions.


LISP interpreter
----------------
The main interpreter functions are translated from LISP to Python almost identically.
They do include some extra calls to utilities for error checking, such as verifying that
functions and special forms are called with the correct number of arguments.


Interactive toplevel
--------------------
For ease of use, some color is added to the input and output by using extended ASCII
characters.

In interactive mode, input may span multiple lines. The whole expression gets evaluated
once the parentheses match, or once they clearly cannot match.


TODO:
----
-there must be a way to write this more elegently. There are C++ versions with fewer
 lines!
-implementation is an almost exact translation from the lisp meta-definition. Instead,
 use some other functions and data structures to speed it up and make the code easier to
 read. This goes along with the tail recursion idea, too.
-Don't rely on Python for recursion: it only supports up to 1000 recursive calls, and
 has no support for tail recursion. Instead, use my own stack and implement tail
 recursion.
-write a garbage collection algorithm rather than relying on python.
-add support for arbitrary car and cdr composites (eg caar, cadaddr, etc)
-implement higher order functions (ie function pointers)
-Consolidate atom checking
-make what can be an atom more restrictive
-change s-expression class to not rely on so many regular expression calls. class system?
-write a more formal scanner/lexer/parser combo
-Implement QUOTE as single quote: '
-Allow dumping to file from interpreter
-Find a more elegent way to represent primitives, rather than just instantiating them
 from hard-coded strings.
-Extend help system. Make it available to users, so that they can write help comments
 for their user-defined functions.
-Allow floats
-write other lisp functions, like apply, mapcar, reverse, len, flatten, last, member, append, etc.
 Perhaps write these in LISP (see TODO about making extensible)
-allow importing from other files. Use this to extend my language with functions written in
 lisp.
-write a compiler (look at LLVM)
-packages, bignums
-look into Meta Object Protocol

-finally, when all above is done, use what I've learned to write it correctly in C.

